---
title: "Wifi location"
author: "David Gibert Bosque"
date: "December 3, 2018"
output: html_document
---
```{r include=FALSE}
rm(list = ls())
```

```{r include=FALSE}
### LIBRARIES ###
library(dplyr)
library(ggplot2)
```

```{r}
### LOADING DATA ###
setwd("C:/Users/David/Google Drive/Github/task3-2-wifi-dgibert17")

df.train = read.csv("training.csv")
df.val = read.csv("validation.csv")

sum(names(df.train) == names(df.val))
```
*Ambos DF tienen los mismos atributos*



the validation fingerprints were
taken 3 months later than the training ones, and some
WAPs disappeared and new ones were introduced.

From the 520 detected WAPs in the UJIIndoorLoc
database, 312 of them were detected in training and
validation phases. 153 WAPs were only detected in
the training phase, and 55 new WAPs appeared in the
validation phase




Como se quitaron WAPs, en el validation test habra WAPs cuyos valores sean todo 100, porque al no estar, obviamente no podran ser registrados por un dispositivo.

Por tanto, primero quitaremos los WAPs del validation que sean inutiles, luego igualaremos el DF de training con los mismos atributos del validation.
```{r}
WAPnotDetected.val = as.character()

for (i in 1:which(names(df.val)=="WAP520")){
  if (sum(df.val[i]) == 100*nrow(df.val)){
    #cat("El", names(df.val[i]), "no ha sido detectado por ningun dispositivo en el validation\n")
    WAPnotDetected.val = c(WAPnotDetected.val, names(df.val[i]))
  }
}

WAPnotDetected.tr = as.character()

for (i in 1:which(names(df.train)=="WAP520")){
  if (sum(df.train[i]) == 100*nrow(df.train)){
    #cat("El", names(df.train[i]), "no ha sido detectado por ningun dispositivo en el training\n")
    WAPnotDetected.tr = c(WAPnotDetected.tr, names(df.train[i]))
  }
}

# df.WAPnotDetected.val = df.val[, c(WAPnotDetected.val, names(df.val[521:529]))]

# cat("El", round(length(WAPnotDetected.val)/520*100),"% de los WAPs no han sido detectados por ningun dispositivo en el training. La universidad esta perdiendo dinero con estos hardware. (Hay que comprobar si ocurre lo mismo para el test).")
```

## Visualizamos cuales son los WAPs del validation set que no son detectados por almenos un dispositivo y los quitamos del DF.
```{r}
WAPnotDetected.val
which(names(df.val) %in% WAPnotDetected.val) #Estos son los indices de los atributos que no son detectados en el validation set, por lo que quitaremos estos atributos del validation set.

df.val = df.val[, -which(names(df.val) %in% WAPnotDetected.val)]
df.train = df.train[, -which(names(df.train) %in% WAPnotDetected.tr)]
```

## Buscamos cuales son los atributos que comparten ambos DFs. El intersect. Asi, despues podremos coger los indices de los atributos del intersect y seleccionarlos para cada uno de los dos DFs, por lo que ambos quedaran con la misma info.
```{r}
tr.in.val.idxs = which(names(df.train) %in% names(df.val))
df.train = df.train[, tr.in.val.idxs]

val.in.tr.idxs = which(names(df.val) %in% names(df.train))
df.val = df.val[, val.in.tr.idxs]

sum(names(df.train) == names(df.val))
```


## Ahora vamos a buscar si hay capturas en TRAINING que no han sido detectadas por ningun WAP o si han sido detectadas unicamente por 1 WAP, las cuales podremos quitar del DF y estudiarlas en un DF diferente, para ver si tienen algo en comun.
```{r}
DEVICEnotDetected.tr = c()
DEVICEdetected1WAP.tr = c()

for (i in 1:nrow(df.train)){
  if (sum(df.train[i, 1:last(grep(pattern = "WAP", names(df.train)))]) == 100*last(grep(pattern = "WAP", names(df.train)))){
    #print(rownames(df.train[i,]))
    DEVICEnotDetected.tr = c(DEVICEnotDetected.tr, as.numeric(rownames(df.train[i,])))
  } else if (sum(df.train[i, 1:last(grep(pattern = "WAP", names(df.train)))] != 100) == 1){
    #print(rownames(df.train[i,]))
    DEVICEdetected1WAP.tr = c(DEVICEdetected1WAP.tr, as.numeric(rownames(df.train[i,])))
  }
}

# names(df.train[first(grep("[^WAP0-9]", names(df.train)))])

df.DEVICESnotDetected.tr = df.train[DEVICEnotDetected.tr, 313:length(names(df.train))]
df.DEVICEdetected1WAP.tr = df.train[DEVICEdetected1WAP.tr, 313:length(names(df.train))]

DEVICESrm.tr = sort(c(DEVICEnotDetected.tr, DEVICEdetected1WAP.tr))

df.train = df.train[-DEVICESrm.tr, ]
```
*Ahora el DF TRAINING solo contiene rows con capturas (dispositivos) que han detectado como minimo 2 WAPs.*

## Ahora vamos a buscar si hay capturas en VALIDATION que no han sido detectadas por ningun WAP o si han sido detectadas unicamente por 1 WAP, las cuales podremos quitar del DF y estudiarlas en un DF diferente, para ver si tienen algo en comun.
```{r}
DEVICEnotDetected.val = c()
DEVICEdetected1WAP.val = c()

for (i in 1:nrow(df.val)){
  if (sum(df.val[i, 1:last(grep(pattern = "WAP", names(df.val)))]) == 100*last(grep(pattern = "WAP", names(df.val)))){
    #print(rownames(df.val[i,]))
    DEVICEnotDetected.val = c(DEVICEnotDetected.val, as.numeric(rownames(df.val[i,])))
  } else if (sum(df.val[i, 1:last(grep(pattern = "WAP", names(df.val)))] != 100) == 1){
    #print(rownames(df.val[i,]))
    DEVICEdetected1WAP.val = c(DEVICEdetected1WAP.val, as.numeric(rownames(df.val[i,])))
  }
}

DEVICEnotDetected.val
DEVICEdetected1WAP.val

df.val = df.val[-DEVICEdetected1WAP.val, ]
```
*No hay ningun dispositivo en el VALIDATION que no haya sido detectado por ningun WAP. Todos han sido detectados por almenos 1 WAP. Ademas, solo hay un dispositivo que haya sido detectado por unicamente 1 WAP, el cual tambien quitamos.*

## Dividiremos los datos de training por edificio, para visualizar la forma de los edificios a partir de la localizacion (latitud y longitud) de las capturas. Tambien creamos los edificios para el validation, de momento por razones de visualizacion. Mas adelante ya veremos para que mas. Si que tendra sentido visualizar la distribucion del validation sobre el training por edificio (incluso por planta) despues de hacer la prediccion de edificio y planta, para ver la distancia entre el valor real y el predicho de una manera visual.
#### Podria tener sentido: Como un dispositivo detecta de media unos 17 WAPs, tiene sentido agrupar por edificio la informacion, ya que asi podremos eliminar muchos de los WAPs, ya que no tiene sentido tener en info de WAPs de un edificio diferente al que se esta tomando la captura. Incluso podriamos filtrar por plantas contiguas, esto lo hare mas adelante.
```{r}
### CREATING TRAIN BUILDINGS ###

df.trainB0 = df.train %>%
  filter(BUILDINGID == 0)

df.trainB1 = df.train %>%
  filter(BUILDINGID == 1)

df.trainB2 = df.train %>%
  filter(BUILDINGID == 2)


### CREATING VALIDATION BUILDINGS ###

df.valB0 = df.val %>%
  filter(BUILDINGID == 0)

df.valB1 = df.val %>%
  filter(BUILDINGID == 1)

df.valB2 = df.val %>%
  filter(BUILDINGID == 2)
```

## Obervamos la distribucion de las capturas del training que crean la forma de los edificios del campus.
```{r}
ggplot(data = df.train, mapping = aes(x = LONGITUDE, y = LATITUDE, color = as.factor(BUILDINGID))) +
  geom_point()

ggplot(data = df.trainB0, mapping = aes(x = LONGITUDE, y = LATITUDE)) +
  geom_point(color = "Red")

ggplot(data = df.trainB1, mapping = aes(x = LONGITUDE, y = LATITUDE)) +
  geom_point(color = "DarkGreen")

ggplot(data = df.trainB2, mapping = aes(x = LONGITUDE, y = LATITUDE)) +
  geom_point(color = "Blue")
```

## Obervamos tambien la distribucion de las capturas del validation.
```{r}
ggplot(data = df.val, mapping = aes(x = LONGITUDE, y = LATITUDE, color = as.factor(BUILDINGID))) +
  geom_point()

ggplot(data = df.valB0, mapping = aes(x = LONGITUDE, y = LATITUDE)) +
  geom_point(color = "Red")

ggplot(data = df.valB1, mapping = aes(x = LONGITUDE, y = LATITUDE)) +
  geom_point(color = "DarkGreen")

ggplot(data = df.valB2, mapping = aes(x = LONGITUDE, y = LATITUDE)) +
  geom_point(color = "Blue")
```
*Parece que la distribucion de las observaciones del validation es buena ya que crea la forma del edifico como tal. Aunque estos son los valores reales o conocidos, lo interesante sera hacer el mismo plot de la distribucion de las observaciones cuando hayamos hecho la prediccion sobre el building, floor...*















## Comprobamos que el WAP001 es detectado almenos en un edificio tanto en training como en validation sets.
```{r}
table(df.trainB0$WAP001)
table(df.trainB1$WAP001)
table(df.trainB2$WAP001)


table(df.valB0$WAP001)
table(df.valB1$WAP001)
table(df.valB2$WAP001)
```
*Esto indica que podemos eliminar los datos del WAP001 del edificio 1 y 2. Sabemos que ese WAP pertenece al edificio 0 y no esta detectado por ningun dispositivo en otro edificio.*







