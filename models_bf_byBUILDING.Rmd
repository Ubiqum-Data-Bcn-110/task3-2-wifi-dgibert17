---
title: "models_floor_byBUILDING"
author: "David Gibert Bosque"
date: "December 14, 2018"
output: html_document
---
```{r include=FALSE}
rm(list = ls())
```

```{r include=FALSE}
### LIBRARIES ###
library(dplyr)
library(Metrics)
library(rpart)
library(doParallel)
library(rpart.plot)
library(fastDummies)
library(ggplot2)
library(elasticnet)
library(lars)
library(caret)
library(AppliedPredictiveModeling)
library(e1071)
library(pls)
library(plotly)
```

```{r include=FALSE}
## LOADING DATA
setwd("C:/Users/David/Google Drive/Github/task3-2-wifi-dgibert17")

load(file = "training.Rdata")
load(file = "validation.Rdata")

# cl <- makeCluster(3)
# doParallel:::registerDoParallel(cl)
```

## Dividimos los datos por edificios para que haya menos interferencia de WAPs de otros edificios. Detectaremos que WAPs no son registrados en cada edificio y los quitaremos.
```{r}
df.trainB0 = df.train %>%
  filter(BUILDINGID == 0)

df.trainB1 = df.train %>%
  filter(BUILDINGID == 1)

df.trainB2 = df.train %>%
  filter(BUILDINGID == 2)


B0.vec = c()
B1.vec = c()
B2.vec = c()

for (i in 1:last(grep(pattern = "WAP", names(df.trainB0)))){
  if (sum(df.trainB0[,i]) == 100*nrow(df.trainB0)){
    B0.vec = c(B0.vec, i)
    # print(i)
  }
}

for (i in 1:last(grep(pattern = "WAP", names(df.trainB1)))){
  if (sum(df.trainB1[,i]) == 100*nrow(df.trainB1)){
    B1.vec = c(B1.vec, i)
    # print(i)
  }
}

for (i in 1:last(grep(pattern = "WAP", names(df.trainB2)))){
  if (sum(df.trainB2[,i]) == 100*nrow(df.trainB2)){
    B2.vec = c(B2.vec, i)
    # print(i)
  }
}


df.trainB0 = df.trainB0[,-B0.vec]
df.trainB1 = df.trainB1[,-B1.vec]
df.trainB2 = df.trainB2[,-B2.vec]


### TAMBIEN HAY QUE HACERLO PARA EL VALIDATION PORQUE TENDREMOS LAS OBSERVACIONES SEPARADAS POR EDIFICIOS CUANDO LOS HAYAMOS PREDICHO.
df.valB0 = df.val %>%
  filter(BUILDINGID == 0)

df.valB1 = df.val %>%
  filter(BUILDINGID == 1)

df.valB2 = df.val %>%
  filter(BUILDINGID == 2)


B0.vec = c()
B1.vec = c()
B2.vec = c()

for (i in 1:last(grep(pattern = "WAP", names(df.valB0)))){
  if (sum(df.valB0[,i]) == 100*nrow(df.valB0)){
    B0.vec = c(B0.vec, i)
    # print(i)
  }
}

for (i in 1:last(grep(pattern = "WAP", names(df.valB1)))){
  if (sum(df.valB1[,i]) == 100*nrow(df.valB1)){
    B1.vec = c(B1.vec, i)
    # print(i)
  }
}

for (i in 1:last(grep(pattern = "WAP", names(df.valB2)))){
  if (sum(df.valB2[,i]) == 100*nrow(df.valB2)){
    B2.vec = c(B2.vec, i)
    # print(i)
  }
}


df.valB0 = df.valB0[,-B0.vec]
df.valB1 = df.valB1[,-B1.vec]
df.valB2 = df.valB2[,-B2.vec]
```


## INTERSECT Train Bx - Val Bx
```{r}
tr.in.val.idxs.B0 = which(names(df.trainB0) %in% names(df.valB0))
df.trainB0 = df.trainB0[, tr.in.val.idxs.B0]

val.in.tr.idxs.B0 = which(names(df.valB0) %in% names(df.trainB0))
df.valB0 = df.valB0[, val.in.tr.idxs.B0]

sum(names(df.trainB0) == names(df.valB0))

# intersect(x = names(df.train), y = names(df.val))
```



#### PREDICCIONES SOBRE FLOOR - POR CADA EDIFICIO POR SEPARADO
## KNN para floor - B0, B1 y B2
```{r}
# df.val$BUILDINGID = svmRad.pred.building #Cambiamos los valores reales por los predichos por SVMRAD que es el que mejor prediccion hacia.

floor.vec.B0 = createDataPartition(y = df.trainB0$FLOOR, p = 0.05)
floor.vec.B1 = createDataPartition(y = df.trainB1$FLOOR, p = 0.05)
floor.vec.B2 = createDataPartition(y = df.trainB2$FLOOR, p = 0.05)

# Training data
# floor.tr = df.train[floor.vec$Resample1, c(1:last(grep(pattern = "WAP", names(df.train))), which(names(df.train) == "FLOOR"))]
floor.tr.B0 = df.trainB0[floor.vec.B0$Resample1, c(1:last(grep(pattern = "WAP", names(df.trainB0))), 142)]

floor.tr.B0$FLOOR = factor(floor.tr.B0$FLOOR)

# Test data
# VALIDATION DF

# Tabla de proporciones para ver que la proporcion de observaciones por BUILDING es la misma en el DF original que en el building.tr
# prop.table(table(df.train$BF))
# prop.table(table(building.tr$BF))

ctrl = trainControl(method = "repeatedcv",
                    number = 3,
                    repeats = 10)

knn.fit.floor.B0 = train(FLOOR~.,
                method = "knn",
                trControl = ctrl,
                data = floor.tr.B0)
knn.fit.floor.B0

knn.pred.floor.B0 = predict(knn.fit.floor.B0, df.valB0)
accuracy(actual = df.valB0$FLOOR, predicted = knn.pred.floor.B0)

#Cuantas observaciones hay predichas por edificio y cuantas hay en realidad en total.
table(knn.pred.floor.B0)
table(df.valB0$FLOOR)

#Cuantos dispositivos se han clasificado mal por cada edificio.
abs(table(knn.pred.floor.B0) - table(df.valB0$FLOOR))
```

## SVM para floor - B0, B1 y B2
```{r warning=FALSE}
## SVM para floor
svmLin.fit.floor.B0 <- train(FLOOR~.,
                    method = "svmLinear",
                    trControl = ctrl,
                    data = floor.tr.B0
                   )
svmLin.fit.floor.B0

svmLin.pred.floor.B0 = predict(svmLin.fit.floor.B0, df.valB0)
accuracy(actual = df.valB0$FLOOR, predicted = svmLin.pred.floor.B0)


svmRad.fit.floor.B0 <- train(FLOOR~.,
                    method = "svmRadial",
                    trControl = ctrl,
                    data = floor.tr.B0
                   )
svmRad.fit.floor.B0

svmRad.pred.floor.B0 = predict(svmRad.fit.floor.B0, df.valB0)
accuracy(actual = df.valB0$FLOOR, predicted = svmRad.pred.floor.B0)


#Cuantas observaciones hay predichas por edificio y cuantas hay en realidad en total.
table(svmRad.pred.floor.B0)
table(df.valB0$FLOOR)

#Cuantos dispositivos se han clasificado mal por cada edificio.
abs(table(svmRad.pred.floor.B0) - table(df.valB0$FLOOR))
```

## RF para floor - B0, B1 y B2
```{r}
rf.fit.floor.B0 = train(FLOOR~.,
                  data = floor.tr.B0,
                  method = "rf",
                  ntree = 50,
                  trControl = ctrl,
                  allowParallel = TRUE
                  )

rf.pred.floor.B0 = predict(rf.fit.floor.B0, df.valB0)
accuracy(actual = df.valB0$FLOOR, predicted = rf.pred.floor.B0)

#Cuantas observaciones hay predichas por edificio y cuantas hay en realidad en total.
table(rf.pred.floor.B0)
table(df.valB0$FLOOR)

#Cuantos dispositivos se han clasificado mal por cada edificio.
abs(table(rf.pred.floor.B0) - table(df.valB0$FLOOR))
```